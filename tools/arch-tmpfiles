#!/bin/bash
#
# /usr/lib/initscripts/arch-tmpfiles
#
# Control creation, deletion, and cleaning of volatile and temporary files
#

warninvalid() {
	printf "%s:line %d: ignoring invalid entry\n" "${files[$TOTALNUM]}" "${linenums[$TOTALNUM]}"
	(( ++error ))
} >&2

checkparams() {
	local parmreq=$1; shift
	local path=$1 mode=$2 uid=$3 gid=$4 age=$5

	# parmcount must be >= parmreq
	if (( $# < parmreq )); then
		return 1
	fi

	# mode must be valid octal and 3 or 4 digits
	if [[ $mode && ! $mode =~ ^[0-7]{3,4}$ ]]; then
		return 1
	fi

	# uid must be numeric or a valid user name
	# don't try to resolve numeric IDs in case they don't exist
	if [[ $uid ]]; then
		if [[ $uid != +([0-9]) ]] && ! getent passwd "$uid" >/dev/null; then
			return 1
		fi
	fi

	# gid must be numeric or a valid group name
	# don't try to resolve numeric IDs in case they don't exist
	if [[ $gid ]]; then
		if [[ $gid != +([0-9]) ]] && ! getent group "$gid" >/dev/null; then
			return 1
		fi
	fi

	# age must be list of numerics separated by the following postfixes:
	# s, sec, m, min, h, d, w
	if [[ $age && $age != '-' ]]; then
		if [[ ! $age =~ ^([0-9]+(s|sec|m|min|h|d|w)?)+$ ]]; then
			return 1
		fi
	fi

	return 0
}

relabel() {
	local -a paths=($1)
	local mode=$2 uid=$3 gid=$4

	if ! checkparams 4 "$@"; then
		warninvalid
		return
	fi

	for path in "${paths[@]}"; do
		if [[ -e $path ]]; then
			[[ $uid != '-' ]] && chown $CHOPTS "$uid" "$path"
			[[ $gid != '-' ]] && chgrp $CHOPTS "$gid" "$path"
			[[ $mode != '-' ]] && chmod $CHOPTS "$mode" "$path"
		fi
	done
}

parse_age() {
	local seconds=0
	local numbers=(${1//[^0-9]/ })
	local units=(${1//[0-9]/ })

	for (( i = 0; i < ${#numbers[@]}; i++ )); do
		if [ "${units[i]}" == "m" ] || [ "${units[i]}" == "min" ]; then
			(( seconds += numbers[i] * 60 ))
		elif [ "${units[i]}" == "h" ]; then
			(( seconds += numbers[i] * 3600 ))
		elif [ "${units[i]}" == "d" ]; then
			(( seconds += numbers[i] * 86400 ))
		elif [ "${units[i]}" == "w" ]; then
			(( seconds += numbers[i] * 604800 ))
		else
			(( seconds += numbers[i] ))
		fi
	done

	echo $seconds
}

in_list() {
	local search=$1

	for item in "${EXCLUDE_LIST[@]}"; do
		[[ "$search" == $item ]] && return 0
	done

	return 1
}

_f() {
	# Create a file if it doesn't exist yet
	local path=$1 mode=$2 uid=$3 gid=$4

	if ! checkparams 4 "$@"; then
		warninvalid
		return
	fi

	if [[ ! -e $path ]]; then
		install -m"$mode" -o"$uid" -g"$gid" /dev/null "$path"
	fi
}

_F() {
	# Create or truncate a file
	local path=$1 mode=$2 uid=$3 gid=$4

	if ! checkparams 4 "$@"; then
		warninvalid
		return
	fi

	install -m"$mode" -o"$uid" -g"$gid" /dev/null "$path"
}

_d() {
	# Create a directory if it doesn't exist yet
	local path=$1 mode=$2 uid=$3 gid=$4 age=$5

	if ! checkparams 4 "$@"; then
		warninvalid
		return
	fi

	if (( CLEAN )); then
		if [[ $age ]] && [[ -d "$path" ]]; then
			local age=$(parse_age $5)
			local current_time=$(date +%s)
			local mod_time=$(stat -c %Y "$path")
			if (( (current_time - mod_time) > age )); then
				for file in $(find -P "$path" -mindepth 1 | sort -r); do
					! in_list "$file" && rm -fd "$file"
				done
			fi
		fi
	fi

	if (( CREATE )); then
		if [[ ! -d "$path" ]]; then
			install -d -m"$mode" -o"$uid" -g"$gid" "$path"
		fi
	fi
}

_D() {
	# Create or empty a directory
	local path=$1 mode=$2 uid=$3 gid=$4

	if ! checkparams 4 "$@"; then
		warninvalid
		return
	fi

	if [[ -d $path ]] && (( REMOVE )); then
		find "$path" -mindepth 1 -maxdepth 1 -xdev -exec rm -rf {} +
	fi

	_d "$@"
}

_p() {
	# Create a named pipe (FIFO) if it doesn't exist yet
	local path=$1 mode=$2 uid=$3 gid=$4

	if ! checkparams 4 "$@"; then
		warninvalid
		return
	fi

	if [[ ! -p "$path" ]]; then
		mkfifo -m$mode "$path"
		chown "$uid:$gid" "$path"
	fi
}

_x() {
	# Ignore a path during cleaning. Use this type to exclude paths from clean-up as
	# controlled with the Age parameter. Note that lines of this type do not
	# influence the effect of r or R lines. Lines of this type accept shell-style
	# globs in place of of normal path names.
	local path=$1

	if ! checkparams 1 "$@"; then
		warninvalid
		return
	fi

	EXCLUDE_LIST+=("$path*(/*)")
}

_X() {
	# Ignore a path during cleanup. Use this type to prevent path removal as controlled
	# with the Age parameter. Note that if path is a directory, content of a directory is not
	# excluded from clean-up, only directory itself. Lines of this type accept
	# shell-style globs in place of normal path names.
	local path=$1

	if ! checkparams 1 "$@"; then
		warninvalid
		return
	fi

	EXCLUDE_LIST+=("$path")
}

_r() {
	# Remove a file or directory if it exists. This may not be used to remove
	# non-empty directories, use R for that. Lines of this type accept shell-style
	# globs in place of normal path names.
	local path
	local -a paths=($1)

	if ! checkparams 1 "$@"; then
		warninvalid
		return
	fi

	for path in "${paths[@]}"; do
		if [[ -f $path ]]; then
			rm -f "$path"
		elif [[ -d $path ]]; then
			rmdir "$path"
		fi
	done
}

_R() {
	# Recursively remove a path and all its subdirectories (if it is a directory).
	# Lines of this type accept shell-style globs in place of normal path names.
	local path
	local -a paths=($1)

	if ! checkparams 1 "$@"; then
		warninvalid
		return
	fi

	for path in "${paths[@]}"; do
		[[ -d $path ]] && rm -rf --one-file-system "$path"
	done
}

_z() {
	# Set ownership, access mode and relabel security context of a file or
	# directory if it exists. Lines of this type accept shell-style globs in
	# place of normal path names.
	local -a paths=($1)
	local mode=$2 uid=$3 gid=$4

	relabel "$@"
}

_Z() {
	# Recursively set ownership, access mode and relabel security context of a
	# path and all its subdirectories (if it is a directory). Lines of this type
	# accept shell-style globs in place of normal path names.

	CHOPTS=-R relabel "$@"
}

process_lines ()
{
	local actions="$1"

	TOTALNUM=0
	while read -a line; do
		(( ++TOTALNUM ))

		[[ "${line[0]}" != $actions ]] && continue

		# fall back on defaults when parameters are passed as '-'
		if [[ ${line[2]} = '-' ]]; then
			case ${line[0]} in
				p|f|F) line[2]=0644 ;;
				d|D) line[2]=0755 ;;
			esac
		fi
		[[ ${line[3]} = '-' ]] && line[3]='root'
		[[ ${line[4]} = '-' ]] && line[4]='root'

		"_${line[@]}"
	done < <(printf '%s\n' "${lines[@]}")
}

shopt -s nullglob
shopt -s extglob

declare -i CREATE=0 REMOVE=0 CLEAN=0 error=0 LINENUM=0 TOTALNUM=0
declare FILE=
declare -A fragments
declare -a tmpfiles_d=(
	/usr/lib/tmpfiles.d/*.conf
	/etc/tmpfiles.d/*.conf
	/run/tmpfiles.d/*.conf
)
declare -a EXCLUDE_LIST lines linenums files

while (( $# )); do
	case $1 in
		--create) CREATE=1 ;;
		--remove) REMOVE=1 ;;
		--clean) CLEAN=1 ;;
		*) break ;;
	esac
	shift
done

if (( !(CREATE + REMOVE + CLEAN) )); then
	printf 'usage: %s [--create] [--remove] [--clean] [FILES...]\n' "${0##*/}"
	exit 1
fi

# directories declared later in the tmpfiles_d array will override earlier
# directories, on a per file basis.
# Example: `/etc/tmpfiles.d/foo.conf' supersedes `/usr/lib/tmpfiles.d/foo.conf'.
for path in "${tmpfiles_d[@]}"; do
	[[ -f $path ]] && fragments[${path##*/}]=${path%/*}
done

# catch errors in functions so we can exit with something meaningful
set -E
trap '(( ++error ))' ERR

# loop through the gathered fragments, sorted globally by filename.
# `/run/tmpfiles/foo.conf' will always be read after `/etc/tmpfiles.d/bar.conf'
while read -d '' fragment; do
	LINENUM=0

	if [[ -z ${fragments[$fragment]} ]]; then
		printf 'warning: %s does not found\n' "$fragment"
		continue
	fi

	printf -v FILE '%s/%s' "${fragments[$fragment]}" "$fragment"

	### FILE FORMAT ###
	# 0    1              2    3    4    5
	# Type Path           Mode UID  GID  Age
	# d    /run/user      0755 root root 10d

	# omit read's -r flag to honor escapes here, so that whitespace can be
	# escaped for paths. We will _not_ honor quoted paths.
	while read -a line; do
		(( ++LINENUM ))

		# skip over comments and empty lines
		if (( ! ${#line[*]} )) || [[ ${line[0]:0:1} = '#' ]]; then
			continue
		fi

		# whine about invalid entries
		if ! type -t _${line[0]} >/dev/null; then
			warninvalid
			continue
		fi

		(( ++TOTALNUM ))
		lines[$TOTALNUM]="${line[@]}"
		linenums[$TOTALNUM]=$LINENUM
		files[$TOTALNUM]="$FILE"
	done <"$FILE"
done < <(printf '%s\0' "${@:-${!fragments[@]}}" | sort -z)

# Fill exclude list first
(( CLEAN )) && process_lines "[xX]"

(( CREATE )) && process_lines "[fFpzZ]"
(( REMOVE )) && process_lines "[rR]"
process_lines "[dD]"

exit $error

# vim: set ts=2 sw=2 noet:
